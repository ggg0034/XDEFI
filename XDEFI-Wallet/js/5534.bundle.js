!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},t=(new Error).stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="502b8597-c2bc-485f-b27d-b64bf97945b5",e._sentryDebugIdIdentifier="sentry-dbid-502b8597-c2bc-485f-b27d-b64bf97945b5")}catch(e){}}();var _global="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};_global.SENTRY_RELEASE={id:"28.2.2"},(self.webpackChunkxdefi_extension=self.webpackChunkxdefi_extension||[]).push([[5534],{835534:(e,t,s)=>{s.a(e,(async(e,a)=>{try{s.d(t,{Z:()=>Ke});var r=s(264487),i=s(914096),n=s(244586),o=s(942274),l=s(409669),d=s.n(l),c=s(135974),h=s(244431),u=s.n(h),p=s(209030),y=s(379372),g=s(133156),m=s(539441),w=s(350144),f=s(177616),I=s(739989),b=s(626423),v=s(46461),C=s(435161),k=s.n(C),T=s(478718),P=s.n(T),S=s(363119),Z=s(519416),A=s(42763),B=s(556138),K=s(691438),x=s(628790),R=s(847001),F=s(831352),_=s(680528),W=s(25022),D=s(427504),N=s(640610),O=s(270900),$=s(572574),J=s(993150),E=s(446010),j=s(358892),L=s(316683),M=s(693246),z=s(605930),V=s(603874),U=s(905479),G=s(705891),H=s(972335),X=s(569252),Y=s(406253),q=s(173431),Q=s(299246),ee=s(834392),te=s(851892),se=s(496486),ae=s(620531),re=s(855192),ie=s(667730),ne=s(703033),oe=s(820813),le=s(81331),de=s(159655),ce=s(943333),he=s(529706),ue=s(177011),pe=s(630292),ye=s(730876),ge=s(803418),me=e([y,g,A,Y,ae,re,oe,le,de,ce,he,ue,pe]);[y,g,A,Y,ae,re,oe,le,de,ce,he,ue,pe]=me.then?(await me)():me;var we=Object.defineProperty,fe=Object.defineProperties,Ie=Object.getOwnPropertyDescriptors,be=Object.getOwnPropertySymbols,ve=Object.prototype.hasOwnProperty,Ce=Object.prototype.propertyIsEnumerable,ke=Math.pow,Te=(e,t,s)=>t in e?we(e,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):e[t]=s,Pe=(e,t)=>{for(var s in t||(t={}))ve.call(t,s)&&Te(e,s,t[s]);if(be)for(var s of be(t))Ce.call(t,s)&&Te(e,s,t[s]);return e},Se=(e,t)=>fe(e,Ie(t)),Ze=(e,t,s)=>(Te(e,"symbol"!=typeof t?t+"":t,s),s),Ae=(e,t,s)=>new Promise(((a,r)=>{var i=e=>{try{o(s.next(e))}catch(e){r(e)}},n=e=>{try{o(s.throw(e))}catch(e){r(e)}},o=e=>e.done?a(e.value):Promise.resolve(e.value).then(i,n);o((s=s.apply(e,t)).next())}));class Be{constructor(){Ze(this,"unsubscribe"),Ze(this,"masterKeys"),Ze(this,"wallets"),Ze(this,"chains"),Ze(this,"dapps"),Ze(this,"dappsProviders"),Ze(this,"assets"),Ze(this,"analytics"),Ze(this,"api"),Ze(this,"populateWalletData",((e,t)=>Ae(this,null,(function*(){yield this.wallets.initWalletData((s=>this.chains.getAllAddresses({seed:s.seed?{seed:s.seed.seed,walletIndex:null!=e?e:0}:void 0,pk:s.pk?s.pk:void 0},t)))})))),Ze(this,"verifyMasterPhrase",(()=>{A.Z.dispatch((0,$.S9)())})),Ze(this,"populateSubAccount",(e=>Ae(this,[e],(function*({seedOrPK:e,masterPassword:t,withInitialTokens:s=!0,keystoreId:a,label:r,imported:i}){if(!e)throw(0,v.t)("app:controller_errors.invalid_seed_or_pk");if(!(yield this.wallets.addSubAccountByPhraseOrPK({seedOrPK:e,password:t,keystoreId:a,imported:i})))throw(0,v.t)("app:controller_errors.account_allready_exists");const n=s?V.bK:this.chains.getAllChainNetworkIds();yield this.populateWalletData(0,n),this.wallets.addKeystoreWallet(r),s&&this.postRestore(),this.masterKeys.clearTemporaryPhrase()})))),Ze(this,"updateCurrency",((e,t,s,a)=>{A.Z.dispatch((0,E.SI)({name:e,symbol:t,title:s,scale:a}))})),Ze(this,"updateMinBalance",(e=>{A.Z.dispatch((0,E.He)(e))})),Ze(this,"addWalletBalance",((e,t)=>{A.Z.dispatch((0,L.l$)({activeWalletId:e,wallets:t})),A.Z.dispatch((0,N.HK)({walletIds:Object.values(t).map((e=>e.id))}))})),Ze(this,"restoreWallets",((e,t,s,a,r,i)=>Ae(this,null,(function*(){return this.addWalletBalance(s,e),this.assets.upgradeTokens(),yield this.masterKeys.unlock(t),(0,S.dC)((()=>{A.Z.dispatch((0,L.EA)(i)),A.Z.dispatch((0,E.dt)(a)),A.Z.dispatch((0,N.Jx)(r))})),yield this.chains.addChainItems(),this.chains.updateBalancesForAllWallets(),{success:!0,message:"You have been restored master keystore, wallets, and settings successfully! Hold on..."}})))),Ze(this,"logger",((e,t)=>I.Z.info(`CONTROLLER: ${e}`,t))),Ze(this,"getAssetBalanceStr",(({chainId:e,symbol:t,address:s,decimals:a,showSymbol:r=!0,showTilde:i=!1,balance:n="0"})=>{try{const o=this.chains.getChainControllerById(e),l=Number(n)?n:this.chains.getBalance(e,t,s),d=(0,D.R6)(o,l,t,null!=a?a:o.getConfig().decimals);return r?(0,D.zr)(new(u())(d),t,i):(0,D.Cb)(new(u())(d),i)}catch(e){return I.Z.error(e),"0"}})),Ze(this,"getAssetBalanceStrThorchain",((e,t=!0,s="0")=>{const a=this.chains.getFirstChainControllerByType(K.J.Thorchain);if(!a)return"0";const r=Number(s)?s:this.chains.getBalanceThorchain(e),i=(0,D.R6)(a,r,e.ticker,a.getConfig().decimals);return t?(0,D.zr)(new(u())(i),e.ticker):(0,D.Cb)(new(u())(i))})),Ze(this,"getFee",((e,t,s)=>Ae(this,null,(function*(){let a,r;const i=this.chains.getChainControllerById(e);switch(i.getType()){case K.J.Binance:const n=yield(0,re.cj)();a=new(u())(n);break;case K.J.Bitcoin:case K.J.Litecoin:case K.J.Dogecoin:case K.J.BitcoinCash:r=(yield i.selfCast().getFeesWithRates(s.memo,s.fromAddress)).rates[t],a=yield i.selfCast().getTransactionFee({speed:t,txData:Se(Pe({},s),{feeRate:r})});break;case K.J.Thorchain:{const e=(yield i.selfCast().getFee()).fastest;a=e.amount().dividedBy(ke(10,e.decimal))}break;case K.J.Terra:{const e=i.selfCast(),a=(null==s?void 0:s.gasPrice)?null==s?void 0:s.gasPrice:void 0,r=yield e.getFee(Se(Pe({},s),{gasPrice:a}));return{fee:new(u())(r.amount.toData()[0].amount).dividedBy(ke(10,e.getConfig().decimals)),speed:t}}case K.J.Near:{const e=yield i.selfCast().getFee(s);a=e.dividedBy(Math.pow(10,i.selfCast().getConfig().decimals))}break;case K.J.Evm:{const e=new(u())(s.gasPrice||0),t=new(u())(s.gasLimit),r=new(u())(s.maxFeePerGas||0),i=new(u())(s.maxPriorityFeePerGas||0);e.gt(0)&&(a=e.multipliedBy(t).dividedBy(1e9).decimalPlaces(18)),i.gt(0)&&r.gt(0)&&(a=r.multipliedBy(t).dividedBy(y.uR))}break;case K.J.Solana:a=new(u())(5e3).dividedBy(ke(10,9));break;case K.J.Cosmos:const o=i.selfCast();a=yield o.getFee();break;default:I.Z.warn(`getFee not implemented for chainId ${e}`),a=new(u())("0")}return new Promise((e=>e({fee:a,feeRate:r,speed:t})))})))),Ze(this,"getAssetAddressDecimals",((e,t)=>{var s,a;const r=this.chains.getChainControllerById(e);let i,n;return r.getType()===K.J.Binance?(i=t.address||"",n=t.decimals||_.KV.A18):r.getType()===K.J.Terra?(i=t.address||"",n=t.decimals||_.KV.A6):r.getType()===K.J.Solana?(i=null!=(s=t.address)?s:"",n=null!=(a=t.decimals)?a:_.KV.A9):r.getType()===K.J.Near?(i=t.address||"",n=t.decimals||_.KV.A24):(i=t.address||"",n=t.decimals||r.getConfig().decimals),t.lpTokenInfo&&(i=t.address||"",n=t.lpTokenInfo.decimals||_.KV.A18),{address:i,decimals:n}})),Ze(this,"getFormattedBalance",((e,t)=>{var s,a,r;let i;i=this.chains.getChainControllerById(e.chainId).getType()===K.J.Thorchain&&"RUNE"!==e.symbol?this.chains.getBalanceThorchain(e.asset):this.chains.getBalance(e.chainId,e.symbol,null!=(s=e.address)?s:e.id);const n=this.wallets.activeWallet,o=e.lpTokenInfo?e.lpTokenInfo.decimals:e.decimals;let l=t||o||this.chains.getChainControllerById(e.chainId).getConfig().decimals;if(n){const t=null==(r=Object.values((null==(a=n.chainData[e.chainId])?void 0:a.tokens)||{}).find((t=>t.address===e.address)))?void 0:r.decimals;t&&(l=t)}return(0,D.R6)(this.chains.getChainControllerById(e.chainId),i,e.symbol,l)})),Ze(this,"updateTxChain",(e=>{A.Z.dispatch((0,E.G3)({activeChain:e}))})),Ze(this,"createIndexedDB",(()=>Ae(this,null,(function*(){try{yield(0,p.ng)()}catch(e){I.Z.error(`Failed to create indexed db: ${e}`),r.Tb(e)}})))),Ze(this,"initJsonPatchTemplates",(()=>Ae(this,null,(function*(){try{try{if(yield(0,p.i9)())return void I.Z.info("Templates: Already have templates")}catch(e){I.Z.info("Templates: Need to fetch templates")}const e=yield fetch(`${R.Z.get("REST_API")}/static/templates.json`),t=yield e.text();yield(0,p.JD)(t)}catch(e){I.Z.error(`Failed to init json templates: ${e}`),r.Tb(e);try{if(yield(0,p.i9)())return}catch(e){I.Z.error(`Failed to read json patch templates from the store: ${e}`)}finally{setTimeout((()=>{this.initJsonPatchTemplates()}),1e3)}}})))),Ze(this,"fetchAssets",(()=>Ae(this,null,(function*(){try{const e=yield(0,p.zF)("assets"),t=yield(0,ie.V)({after:e,fetchPolicy:"no-cache"});yield this.assets.update(t);const s=new Date;s.setSeconds(0),s.setMilliseconds(0),(0,p.tp)("assets",s).catch(r.Tb);const{loadingAllAssets:a}=A.Z.getState().wallets;a&&A.Z.dispatch((0,L.SM)({loadingAllAssets:!1}))}catch(e){I.Z.error(`Failed to fetch assets: ${e}`)}const e=()=>Ae(this,null,(function*(){try{yield this.assets.fetchUserLPTokens()}catch(t){I.Z.error(`Failed to fetch LP tokens: ${t}`),setTimeout(e,1e3),r.Tb(t)}}));e()})))),Ze(this,"deleteRoute",((e=!0,t,s,a,r)=>{if(this.addSwapToken(t,s,a),window.localStorage.removeItem("inputToken"),window.localStorage.removeItem("outputToken"),t[0]){const a={fromChainId:t[0].inputChainId,fromTokenAddress:t[0].inputAddress,fromTokenSymbol:t[0].inputSymbol,fromAmount:t[0].inputAmount,fromAmountUSD:t[0].inputAmountFiat,toChainId:t[s].outputChainId,toTokenAddress:t[s].outputAddress,toTokenSymbol:t[s].outputSymbol,toAmount:t[s].outputAmount,toAmountUSD:t[s].outputAmountFiat,provider:t[s].name};e&&this.analytics.track(W.uT.SwapCanceledSwap,a)}a===X.BA.Pending?e&&this.addWalletNotification({title:(0,v.t)("swap.alert.delete.pending.title"),message:(0,v.t)("swap.alert.delete.pending.message"),linkName:r,link:r?`${this.chains.getChainControllerById(t[s].inputChainId).getConfig().network.transaction}/${r}`:void 0}):e&&this.addWalletNotification({title:(0,v.t)("swap.alert.delete.title"),message:a===X.BA.Idle?(0,v.t)("swap.alert.delete.message"):void 0}),this.setActiveSwap(void 0),this.updateSwaps(void 0),this.setSwapPending(!1)})),Ze(this,"addSwapToken",((e,t,s)=>Ae(this,null,(function*(){const{activeWalletId:a}=A.Z.getState().wallets,r=A.Z.getState()[B.StoreKeys.Settings].history,i=this.assets.getAllTopAssets().find((s=>s.chainId===e[t].outputChainId&&s.token.id===e[t].outputId));if(i&&s===X.BA.Successful&&i){this.assets.addTokenToWallet(e[t].outputChainId,i.token,a)&&this.addWalletNotification({title:(0,v.t)("swap.alert.added_asset.title",{symbol:i.token.symbol,chainId:this.chains.getChainControllerById(e[t].outputChainId).getConfig().longName}),message:(0,v.t)("swap.alert.added_asset.message"),persisted:!0})}yield this.chains.updateAllChainsBalanceForActiveWallet(),r&&_.N7.find((e=>null==r?void 0:r.location.pathname.includes(e)))&&this.rememberLocation(Se(Pe({},r.location),{pathname:_.ft}),!0)})))),Ze(this,"getFormatedPriceStr",(e=>{const{name:t,symbol:s}=A.Z.getState().settings.currency;if(isNaN(e))return"N/A";const a=(0,Q.pF)(e,ee.UX);return isNaN(e)?"N/A":e>0&&e<.001?`< ${s}0.001 ${t}`:`${s}${a} ${t}`})),Ze(this,"getTransactionProp",((e,t)=>{var s,a;let r=e.tradeRoute.provider.time;"multichain"===(null==(s=e.tradeRoute.provider.name)?void 0:s.toLowerCase())&&(r=600),e.tradeRoute.tradeType===Y.j4.Approval&&(r=60);const i=Number(e.tradeRoute.amountIn),n=Number(e.tradeRoute.amountOut),o=Number(e.tradeRoute.fee.inboundFeeDollar),l=Number(e.tradeRoute.fee.networkFeeDollar),d=Number(e.tradeRoute.priceRateUsdAssetIn),c=Number(e.tradeRoute.priceRateUsdAssetOut),h=r%60,u=Math.floor(r/60),p=(0,q.j6)((0,q.SO)(e.tradeRoute.assetIn.asset.chain),e.tradeRoute.assetIn.asset.chain,this.chains),y=(0,q.j6)((0,q.SO)(e.tradeRoute.assetOut.asset.chain),e.tradeRoute.assetOut.asset.chain,this.chains);let g=`~${u}min ${h}sec`;u?h||(g=`~${u}min`):g=`~${h}sec`;const m={networkFee:`${parseFloat(Number(e.tradeRoute.fee.inboundFeeAsset).toFixed(4))} ${p.getConfig().tokenSymbol}`,networkFeeDollar:this.getFormatedPriceStr(o),providerFeeDollar:this.getFormatedPriceStr(l),inputAmount:i,inputAmountFiat:this.getFormatedPriceStr(i*d),outputAmount:n,outputAmountFiat:this.getFormatedPriceStr(n*c),outputImage:e.tradeRoute.assetOut.asset.image,inputImage:e.tradeRoute.assetIn.asset.image,outputChainId:y.getId(),inputChainId:p.getId(),outputId:t,tradeId:(null==(a=e.transaction)?void 0:a.tradeId)||1,tradeType:e.tradeRoute.tradeType,inputSymbol:e.tradeRoute.assetIn.asset.symbol.split("-")[0],inputAddress:e.tradeRoute.assetIn.asset.contract,outputSymbol:e.tradeRoute.assetOut.asset.symbol.split("-")[0],outputAddress:e.tradeRoute.assetOut.asset.contract,name:e.tradeRoute.provider.name,icon:e.tradeRoute.provider.icon,time:g,minAmountReceived:e.tradeRoute.minAmountReceived,reward:e.tradeRoute.reward};return e.tradeRoute.tradeType===Y.j4.Redeem&&(m.inputChainId=m.outputChainId),m})),Ze(this,"updateSwapStatus",((e,t)=>{var s;const a=null==(s=A.Z.getState()[B.StoreKeys.Swaps].swaps)?void 0:s.output.id,r=()=>Ae(this,null,(function*(){return(0,H.J)(e).then((e=>{var s;if(null==e?void 0:e.error)throw new Error(e.error.message);if(!a)throw new Error("no output token");const r=e.data.routingV2.tradesV2.map((e=>this.getTransactionProp(e,a))),i=e.data.routingV2.tradesV2.findIndex((e=>{var s;return(null==(s=e.status)?void 0:s.txHash)===t})),n=e.data.routingV2.tradesV2[i],o=e.data.routingV2.tradesV2.every((e=>{var t;return(null==(t=e.status)?void 0:t.status)===X.BA.Successful}));if(null==(s=null==n?void 0:n.status)?void 0:s.status){if(n.status.status===X.BA.Pending)return!1;if(n.status.status===X.BA.Successful)if(r.length>1){const e={title:(0,v.t)("swap.alert.completed.multi.title",{index:i+1,total:r.length}),type:"success",message:(0,v.t)("swap.alert.completed.multi.message",{tradeType:(0,se.capitalize)(r[i].tradeType)}),persisted:!0};i===r.length-1&&(e.linkName=(0,v.t)("swap.click_to_view_txn"),e.link=`${this.chains.getChainControllerById(r[i].outputChainId).getConfig().network.transaction}/${t}`),this.addWalletNotification(e)}else this.addWalletNotification({title:(0,v.t)("swap.alert.completed.single.title"),type:"success",message:(0,v.t)("swap.alert.completed.single.message",{tradeType:(0,se.capitalize)(r[i].tradeType)}),linkName:(0,v.t)("swap.click_to_view_txn"),link:`${this.chains.getChainControllerById(r[i].outputChainId).getConfig().network.transaction}/${t}`,persisted:!0});else n.status.status===X.BA.Revert&&this.addWalletNotification({title:(0,v.t)("swap.alert.revert.title"),type:"warning",persisted:!0});return o&&this.deleteRoute(!1,r,r.length-1,X.BA.Successful,""),A.Z.dispatch((0,j.Zk)({swapPending:!1})),!0}return!1})).catch((e=>(I.Z.info("updateSwapStatus",e),!1)))})),i=()=>r().then((e=>{e||setTimeout(i,5e3)}));i()})),Ze(this,"swap",((e,t,s,a)=>Ae(this,null,(function*(){I.Z.info("MasterController - swap",e);const{wallets:r,activeWalletId:i}=A.Z.getState().wallets,n=r[i],o=n.walletInfo.data,l=n.walletInfo.type;switch(l){case M.c.Keystore:case M.c.PkKeystore:if(!a)throw"Must pass walletCredentials";const e=yield this.masterKeys.generatePasswordFromKeystore(o.keystore,a.walletPassword);a.walletPassword=e;break;case M.c.Ledger:case M.c.Trezor:break;default:throw`swap pre-processing not implemented for ${l}`}const d=e.chainId;try{const r=yield this._swap(d,e,i,a);return yield(0,G.r)({tradeId:s,routeId:t,transactionHash:r}),this.updateSwapStatus(t,r),I.Z.info("swap res",{txHash:r}),r}catch(e){throw I.Z.error("swap error",{error:e}),this.setSwapPending(!1),this.addWalletNotification({title:(0,v.t)("general.error"),message:(0,v.t)((0,te.ZP)(e,this.chains.getChainControllerById(d).getType())),type:"error",persisted:!0}),e}})))),Ze(this,"getCachedCurrencies",(()=>Ae(this,null,(function*(){return yield(0,ne.D)()})))),Ze(this,"rememberLocation",((e,t=!1)=>{A.Z.dispatch((0,E.l6)({location:e,force:t}))})),Ze(this,"setActiveSwap",(e=>{A.Z.dispatch((0,j.MA)({activeSwap:e}))})),Ze(this,"setReleaseNotesVersion",(e=>{A.Z.dispatch((0,E.xz)({releaseNotesVersion:e}))})),Ze(this,"updateSwaps",(e=>{A.Z.dispatch((0,j.tJ)({swaps:e}))})),Ze(this,"setReferralInfo",(e=>{A.Z.dispatch((0,E.Kr)(e))})),Ze(this,"addWalletNotification",(e=>{A.Z.dispatch((0,J.We)(Se(Pe({},e),{id:(0,n.Z)()})))})),Ze(this,"addDappNotification",(e=>{A.Z.dispatch((0,J.gq)(Se(Pe({},e),{id:(0,n.Z)()})))})),Ze(this,"removeWalletNotification",(()=>{A.Z.dispatch((0,J.Mz)())})),Ze(this,"removeDappNotification",(()=>{A.Z.dispatch((0,J.Om)())})),Ze(this,"resetNonPersistedNotifications",(()=>{A.Z.dispatch((0,J.Ln)())})),Ze(this,"updateDailyAnalyticsDate",(()=>{A.Z.dispatch((0,E.s1)())})),Ze(this,"setWalletForCampaign",(e=>Ae(this,null,(function*(){try{const t=Object.keys(A.Z.getState().wallets.wallets[e].chainData).reduce(((t,s)=>{const a=this.chains.getChainControllerById(s);return b.mY.hasOwnProperty(a.getConfig().network.chainId)&&(t[b.mY[a.getConfig().network.chainId]]=A.Z.getState().wallets.wallets[e].chainData[s].address),t}),{}),s=Object.entries(t).map((([e,t])=>({chain:e,address:t}))),a=A.Z.getState().settings.userId;yield this.api.post(`${R.Z.get("CAMPAINGS_API")}/campaigns/opt-in`,{userId:a,addresses:s}),A.Z.dispatch((0,O.GC)({walletId:e,chainAddresses:t}))}catch(e){r.Tb(e),I.Z.error("setWalletForCampaign error",{e})}})))),Ze(this,"removeWalletFromCampaign",(()=>Ae(this,null,(function*(){const e=A.Z.getState().settings.userId;try{yield this.api.post(`${R.Z.get("CAMPAINGS_API")}/campaigns/opt-out`,{userId:e}),A.Z.dispatch((0,O.eo)())}catch(e){r.Tb(e),I.Z.error("setWalletForCampaign error",{e})}})))),Ze(this,"removeRootWallets",(()=>{this.wallets.getRootWallets().forEach((e=>{this.wallets.removeRootWallet(e.id),this.masterKeys.removeAccountKey(e.id)}))})),Ze(this,"resetData",(()=>{const{activeWalletId:e}=A.Z.getState().wallets;Object.keys(A.Z.getState().wallets.wallets).includes(e)||this.wallets.selectWallet(Object.keys(A.Z.getState().wallets.wallets)[0]),this.updateTxChain("all"),this.assets.updateActiveAssetChain("all"),this.assets.updateActiveNFTChain("all")})),this.wallets=Object.freeze(new ue.Z(this)),this.chains=new le.Z(this),this.masterKeys=Object.freeze(new he.Z(this.chains)),this.dappsProviders=Object.freeze(new ce.Z),this.dapps=Object.freeze(new de.Z(this.dappsProviders)),this.assets=new oe.Z(this),this.analytics=new ae.Z;const e=(0,c.setupCache)({maxAge:6e4});this.api=d().create({adapter:e.adapter}),this.unsubscribe=null,this.createIndexedDB()}restoreBackupCriticalData(e,t){return Ae(this,arguments,(function*({masterKey:e,accountKeys:t},{type:s,password:a,seed:r}){try{let i=r;s===m.J.ByPassword&&(i=yield(0,x.WR)(e,a));const n={masterKey:yield(0,x.sB)(i,a,0),accountKeys:t};return A.Z.dispatch((0,$.Bp)(n)),yield Promise.all(k()(t,(e=>Ae(this,[e],(function*({keystore:e}){const t=yield this.masterKeys.generatePasswordFromKeystore(e,a),s=yield(0,x.WR)(e,t);return this.wallets.addSubAccountByPhraseOrPK({seedOrPK:s,password:a})}))))),this.postRestore(),!0}catch(e){return I.Z.error(e),!1}}))}postRestore(){this.assets.addTokenToAllWallets()}restoreBackup(e,t){return Ae(this,null,(function*(){const{type:s}=e;if(s!==_.ys.All)return{success:!1,message:"Invalid keystore or password"};let a;try{if(a=(0,g.gb)(e),!a)throw(0,v.t)("app:controller_errors.invalid_backup_data");const{criticalData:s,accounts:r,settings:i,contacts:n,chainConfigs:o}=a,l=P()(a.nftBalances,Object.keys(r.wallets)),{activeWalletId:d,wallets:c}=r,{masterKey:h,accountKeys:u}=s;yield(0,x.WR)(h,t);const p={masterKey:h,accountKeys:u};A.Z.dispatch((0,$.Bp)(p));const y=Object.keys(o),m=this.chains.getAllChainControllers().map((e=>e.getId())),w=y.filter((e=>!m.includes(e)));for(const e of w)A.Z.dispatch((0,U.ws)(o[e])),this.chains.addChainController(o[e]);const f=yield this.restoreWallets(c,t,d,i,l,n);return this.postRestore(),f}catch(s){if("Invalid password"===s)return{success:!1,message:s};const r=a?a.criticalData:(0,g.JC)(e),i=yield this.restoreBackupCriticalData(r,{type:m.J.ByPassword,password:t});return{success:i,message:i?"There were some problems in your backup data! But you have been restored master keystore and wallets successfully! Hold on...":"Invalid backup file or password"}}finally{this.wallets.init(!1)}}))}restoreBackupWithMasterPhrase(e,t,s){return Ae(this,null,(function*(){const{type:a}=s;if(a!==_.ys.All)return{success:!1,message:"Invalid XDEFI Seed phrase"};let r,i;try{r=new ye.H(he.Z.getPhraseFromInput(e))}catch(e){return{success:!1,message:"Invalid XDEFI Recovery code"}}try{if(i=(0,g.gb)(s),!i)throw(0,v.t)("app:controller_errors.invalid_backup_data");const{accounts:e,settings:a,criticalData:n,contacts:o,chainConfigs:l}=i,d=P()(i.nftBalances,Object.keys(e.wallets)),{activeWalletId:c,wallets:h}=e,u=h[c];if(u.walletInfo.type!==M.c.Keystore)throw(0,v.t)("app:controller_errors.wallet_type_is_not_keystore");const p=u.walletInfo.data;if(!p.publickeys)throw(0,v.t)("app:controller_errors.incorrect_wallet_data");const y=(0,x.UL)(p.publickeys),m=(0,z.Jz)(`${r.toString()}${y.toString()}`);if(!p.keystore)throw(0,v.t)("app:controller_errors.no_keystore");const w=p.keystore;try{yield(0,x.WR)(w,m)}catch(e){return{success:!1,message:"Invalid XDEFI Recovery code"}}const{accountKeys:f}=n,I={masterKey:yield(0,x.sB)(r,t,0),accountKeys:f};A.Z.dispatch((0,$.Bp)(I));const b=Object.keys(l),C=this.chains.getAllChainControllers().map((e=>e.getId())),k=b.filter((e=>!C.includes(e)));for(const e of k)A.Z.dispatch((0,U.ws)(l[e])),this.chains.addChainController(l[e]);return yield this.restoreWallets(h,t,c,a,d,o)}catch(e){if("Invalid password"===e)return{success:!1,message:e};const a=i?i.criticalData:(0,g.JC)(s),n=yield this.restoreBackupCriticalData(a,{type:m.J.ByPassword,password:t,seed:r});return{success:n,message:n?(0,v.t)("app:controller_errors.there_were_some_problems_in_your_data"):(0,v.t)("app:controller_errors.invalid_backup_file_or_password")}}finally{this.wallets.init(!1)}}))}generatePasswordFromKeystore(e){const{wallets:t}=A.Z.getState().wallets,s=t[e];if(!s)return Promise.reject(`Wallet id ${e} not found`);if(s.walletInfo.type!==M.c.Keystore&&s.walletInfo.type!==M.c.PkKeystore)return null;const a=s.walletInfo.data;return this.masterKeys.generatePasswordFromKeystore(a.keystore,this.masterKeys.masterPassword)}decrypt(e,t){return Ae(this,null,(function*(){return I.Z.debug({method:"decrypt",dappMessage:e}),new Promise(((s,a)=>Ae(this,null,(function*(){try{const{wallets:r,activeWalletId:i}=A.Z.getState().wallets,n=r[i];if(!n)return a(`Wallet id ${i} not found`);const o=n.walletInfo.data,l=e.raw.params.params[0],d=(0,x.NS)(l),c=e.chainId,h=n.walletInfo.type;let u="";switch(h){case M.c.Keystore:case M.c.PkKeystore:const e=yield this.masterKeys.getAccountSeedPhrase(i,t);e&&(u=this.chains.getPrivateKey(c,{seed:e,walletIndex:o.walletIndex||0}));break;case M.c.Ledger:case M.c.Trezor:u=yield(0,ge.D)(h).getEIP1024SharedSecret(d.ephemPublicKey,o.walletIndex||0,o.derivationPath);break;default:throw`decrypt: Wallet type not supported ${h}`}const p=(0,w.decrypt)(d,u);return I.Z.debug({msg:"decrypt",decryptedMsg:p}),s(p)}catch(e){return I.Z.error({method:"decrypt: not handled",error:e}),a(e)}}))))}))}getEncryptionPublicKey(e,t){return Ae(this,null,(function*(){return I.Z.debug({method:"getEncryptionPublicKey",dappMessage:e}),new Promise(((s,a)=>Ae(this,null,(function*(){try{const{wallets:r,activeWalletId:i}=A.Z.getState().wallets,n=r[i];if(!n)return a(`Wallet id ${i} not found`);const o=n.walletInfo.data,l=this.chains.getChainControllerById(e.chainId),d=n.walletInfo.type;let c="";switch(d){case M.c.Keystore:case M.c.PkKeystore:const e=yield this.masterKeys.getAccountSeedPhrase(i,t);if(e){const t=this.chains.getPrivateKey(l.getId(),{seed:e,walletIndex:o.walletIndex||0});c=(0,w.getEncryptionPublicKey)(t)}break;case M.c.Ledger:case M.c.Trezor:c=yield(0,ge.D)(d).getEIP1024PublicEncryptionKey(o.walletIndex||0,o.derivationPath);break;default:throw`getEncryptionPublicKey: Wallet type not supported ${d}`}return I.Z.debug({msg:"getEncryptionPublicKey",pubKey:c}),s(c)}catch(e){return I.Z.error({method:"getEncryptionPublicKey: not handled",error:e}),a(e)}}))))}))}approveDappsTransaction(e,t,s,a,r){return Ae(this,null,(function*(){return I.Z.debug({method:"approveDappsTransaction",dappMessage:e}),new Promise(((i,n)=>Ae(this,null,(function*(){var o,l;try{const{wallets:d}=A.Z.getState().wallets,c=d[t],h=c.walletInfo.data;if(!c)return n(`Wallet id ${t} not found`);const u=c.walletInfo.type;let p="",y="";switch(u){case M.c.Keystore:case M.c.PkKeystore:if(!a)throw"Must pass walletCredentials";p=yield this.masterKeys.generatePasswordFromKeystore(h.keystore,a.walletPassword),a.walletPassword=p,y=M.c.PkKeystore===u?"PKKEYSTORE":"KEYSTORE";break;case M.c.Ledger:case M.c.Trezor:y="LEDGER";break;default:throw`approveDappTransaction: Wallet type not supported ${u}`}const g=yield this.chains.getChainControllerById(e.chainId).approveDappTransaction(e,t,a,r);I.Z.debug({msg:"approveDappsTransaction",result:g}),this.analytics.track(W.uT.ApproveDappTransaction,{chainId:e.chainId,dappId:new URL((null==(l=null==(o=null==e?void 0:e.origin)?void 0:o.tab)?void 0:l.url)||"http://localhost").hostname,type:s,walletTypeStr:y});const m=Se(Pe({},e),{xdefiId:e.xdefiId,raw:{id:e.xdefiId,result:g}});return Z.browser.extension.getBackgroundPage().processor.reply(m),i(g)}catch(e){return I.Z.error({method:"approveDappsTransaction: not handled",error:e}),n(e)}}))))}))}validateTx(e,t){return I.Z.info("validating Tx for chain: ",e),this.chains.getChainControllerById(e).validateTx(t)}sendTx(e,t,s,a,r){return Ae(this,null,(function*(){var i;I.Z.info("sending Tx for chain: ",e);const{wallets:n}=A.Z.getState().wallets,o=n[s],l=o.walletInfo.data,d=o.walletInfo.type;let c="";switch(d){case M.c.Keystore:case M.c.PkKeystore:if(!r)throw"Must pass walletCredentials";c=yield this.masterKeys.generatePasswordFromKeystore(l.keystore,r.walletPassword),r.walletPassword=c;break;case M.c.Ledger:case M.c.Trezor:break;default:throw`sendTx pre-processing not imeplemented for ${d}`}try{const i=yield this.chains.getChainControllerById(e).sendTx(t,s,r);return this.analytics.track(W.uT.SendAssetSuccess,Se(Pe({},a),{txHash:i})),i}catch(e){throw this.analytics.track(W.uT.SendAssetFailed,Se(Pe({},a),{error:null!=(i=null==e?void 0:e.message)?i:JSON.stringify(e)})),e}}))}signPsbt(e,t,s,a){return Ae(this,null,(function*(){const{wallets:r}=A.Z.getState().wallets,i=r[s],n=i.walletInfo.data,o=i.walletInfo.type;let l="";switch(o){case M.c.Keystore:case M.c.PkKeystore:if(!a)throw"Must pass walletCredentials";l=yield this.masterKeys.generatePasswordFromKeystore(n.keystore,a.walletPassword),a.walletPassword=l;break;case M.c.Ledger:case M.c.Trezor:break;default:throw`sendTx pre-processing not imeplemented for ${o}`}try{return yield this.chains.getChainControllerById(t).signPsbt(e,s,a)}catch(e){throw e}}))}setLoading(e){A.Z.dispatch((0,E.Xt)({loading:e}))}setOnBoarding(e){A.Z.dispatch((0,E.K$)({onBoarding:e}))}setInternalUpgradeRequired(e){A.Z.dispatch((0,E.h5)({internalUpgradeRequired:e}))}toggleInfiniteApproval(){A.Z.dispatch((0,j.t7)())}toggleCustomRecipient(){A.Z.dispatch((0,j.h7)())}setSlippage(e){A.Z.dispatch((0,j.Zj)({slippage:e}))}setSwapPending(e){A.Z.dispatch((0,j.Zk)({swapPending:e}))}_swap(e,t,s,a){return Ae(this,null,(function*(){const{activeWalletId:r}=A.Z.getState().wallets,n=t,l=this.chains.getChainControllerById(e);switch(l.getType()){case K.J.Binance:{const e=Se(Pe({},t),{address:t.address||""});return l.selfCast().sendTx(e,s,a)}case K.J.Bitcoin:case K.J.Litecoin:case K.J.BitcoinCash:return l.selfCast().sendTx(n,s,a);case K.J.Dogecoin:{const e=l.selfCast(),r=yield e.getFeesWithRates(t.memo);return n.feeRate=r.rates[o.FeeOption.Average],e.sendTx(n,s,a)}case K.J.Thorchain:if(t.unsignedStdTx)return yield l.selfCast().signAndBroadcastTx(t.unsignedStdTx,t.fromAddress,r,a);throw"Tx failed";case K.J.Terra:if(t.unsignedStdTx){let e,r=t.memo;if("core/StdTx"===t.unsignedStdTx.type){const{from_address:s,to_address:a,amount:n}=t.unsignedStdTx.value.msg[0].value;e=new i.MsgSend(s,a,null==n?void 0:n.map((e=>i.Coin.fromData(e)))),r=t.unsignedStdTx.value.memo}else{const{sender:s,contract:a,execute_msg:r,coins:n}=t.unsignedStdTx.value;e=new i.MsgExecuteContract(s,a,r,null==n?void 0:n.map((e=>i.Coin.fromData(e))))}const n={memo:r,msgs:[e]};return(yield l.selfCast().signAndBroadcastTx(n,s,t.fromAddress,t.toAddress,a)).txhash}throw"Tx failed";case K.J.Evm:{const e=l.selfCast();let r=yield(0,re.X7)(e);const i=yield e.getNonce(t.fromAddress),n=Se(Pe({address:"",isToken:!1,decimals:e.getConfig().decimals},t),{nonce:i,gasLimit:t.gasLimit||1e6});if(e.support(K.B.Eip1559)){const{maxFeePerGas:e,maxPriorityFeePerGas:s}=r;if(n.maxFeePerGas=Number(e.toFixed(9)),n.maxPriorityFeePerGas=Number(s.toFixed(9)),!t.gasLimit)try{const e=yield l.selfCast().estimateTx(n.fromAddress,n.toAddress,f.parseUnits(n.amount).toString(),n.data),t=Number(e.toString());t<n.gasLimit&&(n.gasLimit=t)}catch(e){}}else r&&(n.gasPrice=Number(r.fast.toFixed(9))||0);return e.sendTx(n,s,a,!0)}case K.J.Solana:return l.selfCast().swap(t,s,a);case K.J.Near:{const e=t.data,r={signerId:t.signerId,receiverId:t.receiverId,actions:e.map((e=>({params:e,type:"FunctionCall"})))},i={chainType:K.J.Near,chainId:F.yp.Near,time:0,xdefiId:0,raw:{params:{transaction:r},method:"signAndSendTransaction"}};return(yield l.approveDappTransaction(i,s,a)).toString()}case K.J.Cosmos:return l.selfCast().swap(t.unsignedStdTx,s,a);default:throw I.Z.error("swap error",{swapObj:t}),`${e} not supported yet`}}))}}Ze(Be,"getWalletIdWithMessage",(e=>{var t,s;const{wallets:a,activeWalletId:r}=A.Z.getState().wallets,i=pe.j8.getFromAccountIMessage(e);if(!i)return r;const n=null==(t=String(i))?void 0:t.toLowerCase(),o=Object.values(a);I.Z.debug({fromAddr:i,walletsArr:o,wallets:a});const l=o.findIndex((t=>{var s,a;return null==(a=null==(s=t.chainData[e.chainId])?void 0:s.address)?void 0:a.toLowerCase().includes(n)}));if(I.Z.debug({res:l}),l<0)throw`Could not find the wallet attached with the dApp message's address: "${n}"`;return null==(s=o[l])?void 0:s.id}));const Ke=Be;a()}catch(e){a(e)}}))}}]);
//# sourceMappingURL=5534.bundle.js.map