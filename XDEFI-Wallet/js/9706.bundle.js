!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},t=(new Error).stack;t&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[t]="2552e349-b44b-4154-9f75-a7c762a4c55f",e._sentryDebugIdIdentifier="sentry-dbid-2552e349-b44b-4154-9f75-a7c762a4c55f")}catch(e){}}();var _global="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};_global.SENTRY_RELEASE={id:"28.2.2"},(self.webpackChunkxdefi_extension=self.webpackChunkxdefi_extension||[]).push([[9706],{529706:(e,t,r)=>{r.a(e,(async(e,n)=>{try{r.d(t,{Z:()=>W});var s=r(276749),o=r(196329),a=r(680528),i=r(626423),l=r(496486),c=r(221378),d=r.n(c),u=r(435161),h=r.n(u),p=r(363119),f=r(42763),y=r(556138),w=r(316683),g=r(628790),m=r(739989),v=r(572574),b=r(446010),k=r(605930),x=r(46461),I=r(204147),_=r(691438),T=r(730876),P=r(721892),S=e([o,f]);[o,f]=S.then?(await S)():S;var K,N,B,A=Object.defineProperty,F=(e,t,r)=>(((e,t,r)=>{t in e?A(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r})(e,"symbol"!=typeof t?t+"":t,r),r),Z=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)},O=(e,t,r)=>(Z(e,t,"read from private field"),r?r.call(e):t.get(e)),R=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},E=(e,t,r,n)=>(Z(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r),M=(e,t,r)=>new Promise(((n,s)=>{var o=e=>{try{i(r.next(e))}catch(e){s(e)}},a=e=>{try{i(r.throw(e))}catch(e){s(e)}},i=e=>e.done?n(e.value):Promise.resolve(e.value).then(o,a);i((r=r.apply(e,t)).next())}));const $=class{constructor(e){R(this,K,void 0),R(this,N,void 0),R(this,B,void 0),F(this,"getNFTBalancesFromStore",(()=>{var e;const t=null==(e=f.Z.getState())?void 0:e.balances;return(0,l.reduce)(t,((e,t,r)=>(e[r]={},(0,l.forEach)(t.chains,((t,n)=>{e[r][n]={nft:t.nft}})),e)),{})})),E(this,B,e),E(this,K,"")}get masterKeystore(){const{keystore:e}=f.Z.getState().masterKeystore;return e}get masterPassword(){return O(this,K)}get masterSeed(){return O(this,N)}get isLocked(){const{locked:e}=f.Z.getState().masterKeystore;return e}get isPhraseVerified(){const{verified:e}=f.Z.getState().masterKeystore;return e}generatePassword(e,t,r){return M(this,null,(function*(){const{defaultBuffer:n}=(0,g.Ku)(e,r),s=Uint8Array.from(n).toString(),{masterKey:o}=this.masterKeystore,a=yield(0,g.WR)(o,t);return E(this,K,t),(0,k.Jz)(`${a}${s}`)}))}generatePasswordFromKeystore(e,t){return M(this,null,(function*(){const{masterKey:r}=this.masterKeystore,n=(0,g.UL)(e.publickeys).toString(),s=yield(0,g.WR)(r,t);return E(this,K,t),(0,k.Jz)(`${s}${n}`)}))}static generatePasswordFromKeystore(e,t){return M(this,null,(function*(){const{keystore:r}=f.Z.getState().masterKeystore,{masterKey:n}=r,s=(0,g.UL)(e.publickeys).toString(),o=yield(0,g.WR)(n,t);return(0,k.Jz)(`${o}${s}`)}))}getAccountSeedPhrase(e,t){return M(this,null,(function*(){const{accountKeys:r,masterKey:n}=this.masterKeystore,s=t||O(this,K),o=d()(r,(t=>t.keystore.id===e));if(!o)throw"Key for specified account was not found";const a=null==o?void 0:o.keystore;if(!a||!a.publickeys||!s)return;const i=yield(0,g.WR)(n,s);E(this,K,s);const l=(0,g.UL)(a.publickeys),c=(0,k.Jz)(`${i}${l.toString()}`);return(0,g.WR)(a,c)}))}createMasterKeystore(e,t){return M(this,null,(function*(){const r=t||new T.H((0,s.generatePhrase)()),n={masterKey:yield(0,g.sB)(r,e,0),accountKeys:[]};return f.Z.dispatch((0,v.Bp)(n)),E(this,K,e),r}))}clearTemporaryPhrase(){E(this,N,void 0)}setTemporaryPhrase(e){E(this,N,e)}checkDuplicateAccount(e,t=0){let r=!1;const{accountKeys:n}=this.masterKeystore,{defaultBuffer:s}=(0,g.Ku)(e,t),o=Array.from(s).toString();return h()(n,(e=>{const{keystore:t}=e,n=(0,g.UL)(t.publickeys);o===n.toString()&&(r=!0)})),r}clearMasterKey(){E(this,K,"")}lockMasterKey(){this.clearMasterKey(),f.Z.dispatch((0,v.M8)())}getMasterPhrase(e){return M(this,null,(function*(){const{masterKey:t}=this.masterKeystore,r=yield(0,g.WR)(t,e);return E(this,K,e),f.Z.dispatch((0,v.wo)()),r}))}changePassword(e,t){return M(this,null,(function*(){const{masterKey:r}=this.masterKeystore,n=yield(0,g.WR)(r,e),s=yield(0,g.sB)(n,t,0);f.Z.dispatch((0,v.L8)(s)),f.Z.dispatch((0,v.wo)()),E(this,K,t)}))}unlock(e,t=!1){return M(this,null,(function*(){var r;try{const n=null==(r=f.Z.getState())?void 0:r.settings.internalUpgradeRequired,{masterKey:s}=this.masterKeystore;yield(0,g.WR)(s,e),E(this,K,e);try{t&&n&&(yield O(this,B).addChainItems()),f.Z.dispatch((0,b.h5)({internalUpgradeRequired:!1}))}catch(e){m.Z.error({msg:"upgradeChains failed",e})}return f.Z.dispatch((0,v.wo)()),!0}catch(e){return m.Z.info("#MARK - unlock master key error",e),!1}}))}validateMasterPassword(e){return M(this,null,(function*(){try{const{masterKey:t}=this.masterKeystore;return yield(0,g.WR)(t,e),E(this,K,e),!0}catch(e){return m.Z.info("#MARK - validate master password error",e),!1}}))}static getPhraseFromInput(e){try{return(0,g.jE)(e)}catch(t){return e}}recoverMasterKeystore(e,t){return M(this,null,(function*(){const{masterKey:r}=this.masterKeystore;let n;try{n=new T.H($.getPhraseFromInput(t))}catch(e){throw(0,x.t)("app:controller_errors.cant_resolve_recovery_code")}const s=(0,g.Ku)(n,0);if(Array.from(s.defaultBuffer).toString()===(0,g.UL)(r.publickeys).toString()){const t=yield(0,g.sB)(n,e,0);return E(this,K,e),f.Z.dispatch((0,v.L8)(t)),!0}throw(0,x.t)("app:controller_errors.cant_resolve_master_keystore")}))}addAccountKey(e,t){const r={rootWalletId:t||e.id,keystore:e};try{return f.Z.dispatch((0,v.FY)(r)),!0}catch(e){m.Z.info("#MARK - ADD ACCOUNT KEY ERROR:",e)}return!1}removeAccountKey(e){f.Z.dispatch((0,v.Fx)(e))}removeAccountKeys(e){(0,p.dC)((()=>{h()(e,(e=>{f.Z.dispatch((0,v.Fx)(e))}))}))}downloadKeystoreAsJson(e,t){return M(this,null,(function*(){var r,n,s;const{wallets:o,activeWalletId:l,contacts:c}=(null==(r=f.Z.getState())?void 0:r.wallets)||{},d=null==(n=f.Z.getState())?void 0:n.settings,{chains:u}=null==(s=f.Z.getState())?void 0:s.chains,{masterKey:h,accountKeys:p}=this.masterKeystore,y=this.getNFTBalancesFromStore();let w;try{w=yield(0,g.WR)(h,e)}catch(e){throw"app:controller_errors.incorrect_master_key_password"}const m=u.reduce(((e,t)=>(e[t.id]=t,e)),{}),v={version:I.du,type:a.ys.All,criticalData:{masterKey:yield(0,g.sB)(w,t,0),accountKeys:p},accounts:{activeWalletId:l,wallets:o},settings:d,nftBalances:y,contacts:c,chainConfigs:m};return(0,i.Hy)(v,"xdefi-backup-all"),{success:!0,message:"All of wallets are exported with their settings."}}))}toggleAutoLockFeature(){f.Z.dispatch((0,b.x7)())}toggleEnableCollectibles(){f.Z.dispatch((0,b.rF)())}updateShowBackupPrompt(e){f.Z.dispatch((0,b.c4)({showBackupPrompt:e}))}updateShowWelcomePrompt(e){f.Z.dispatch((0,b.l1)({showWelcomePrompt:e}))}addBTCPubKeys(e,t){return M(this,null,(function*(){const{wallets:r}=f.Z.getState().wallets,n=self.masterController.chains.getChainControllersByType(_.J.Bitcoin);for(const s of n){const n=yield e.reduce(((e,n)=>M(this,null,(function*(){var a;const l=yield e,c=r[n].walletInfo.data,d=r[n].walletInfo.type;let u="";const h=r[n].chainData[s.getId()];if(!h||(null==h?void 0:h.pubKey))return l;switch(d){case y.WalletType.Keystore:case y.WalletType.PkKeystore:u=yield this.generatePasswordFromKeystore(c.keystore,t);const e=yield(0,g.Jy)(c.keystore,u),d=o.Z.getBtcKeys(e,c.walletIndex,(0,i.XL)(s.selfCast().getConfig().network.activeNetwork));l.push({walletId:n,publicKey:d.publicKey.toString("hex"),chainId:s.getId()});break;case y.WalletType.Ledger:const h=yield(new P.Z).getUTXOAddress(c.walletIndex,c.derivationPath);if((null==(a=r[n].chainData[s.getId()].address)?void 0:a.toLowerCase())!==h.address)throw(0,x.t)("app:controller_errors.wrong_ledger_device");l.push({walletId:n,publicKey:h.publicKey,chainId:s.getId()});case y.WalletType.Trezor:}return l}))),Promise.resolve([]));f.Z.dispatch((0,w.id)(n))}}))}};let C=$;K=new WeakMap,N=new WeakMap,B=new WeakMap;const W=C;n()}catch(e){n(e)}}))},196329:(e,t,r)=>{r.a(e,(async(e,n)=>{try{r.d(t,{Z:()=>oe});var s=r(177616),o=r(264487),a=r(620918),i=r(942274),l=r(276749),c=r(148771),d=r(409669),u=r.n(d),h=r(135974),p=r(244431),f=r(437786),y=r(617656),w=r(23064),g=r(608193),m=r.n(g),v=r(939789),b=r.n(v),k=r(99127),x=r(712685),I=r(847001),_=r(831352),T=r(45217),P=r(739989),S=r(46461),K=r(496486),N=r(59854),B=r.n(N),A=r(255357),F=r(626423),Z=r(42763),O=r(693246),R=r(604690),E=r(628790),M=r(803418),$=r(729357),C=r(882591),W=r(661195),D=r(728147),X=r(16547),L=r(630292),U=r(666293),Buffer=r(348764).Buffer,q=e([Z,R,L]);[Z,R,L]=q.then?(await q)():q;var H=Object.defineProperty,z=Object.defineProperties,J=Object.getOwnPropertyDescriptors,j=Object.getOwnPropertySymbols,V=Object.prototype.hasOwnProperty,Y=Object.prototype.propertyIsEnumerable,G=(e,t,r)=>t in e?H(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,Q=(e,t,r)=>(G(e,"symbol"!=typeof t?t+"":t,r),r),ee=(e,t,r)=>new Promise(((n,s)=>{var o=e=>{try{i(r.next(e))}catch(e){s(e)}},a=e=>{try{i(r.throw(e))}catch(e){s(e)}},i=e=>e.done?n(e.value):Promise.resolve(e.value).then(o,a);i((r=r.apply(e,t)).next())}));const te=e=>e===_.g5.Testnet?y.QW.testnet:y.QW.bitcoin,re={[i.Network.Mainnet]:"84'/0'/0'/0/",[i.Network.Stagenet]:"84'/0'/0'/0/",[i.Network.Testnet]:"84'/1'/0'/0/"},ne=(e,t,r,n=!1)=>{if(!isFinite(b().uintOrNaN(r)))return{};let s=b().transactionBytes([],t),o=0;const a=[],i=b().sumOrNaN(t);for(let l=0;l<e.length;++l){const c=e[l],d=b().inputBytes(c),u=r*d,h=b().uintOrNaN(c.value);if(u>c.value&&!n){if(l===e.length-1)return{fee:r*(s+d)};continue}s+=d,o+=h,a.push(c);if(!(o<i+r*s))return b().finalize(a,t,r)}return{fee:r*s}};class se extends L.Pu{constructor(e){super(e),Q(this,"name"),Q(this,"symbol"),Q(this,"image"),Q(this,"api"),Q(this,"bip32"),Q(this,"ECPair"),Q(this,"broadcastTx",(e=>ee(this,null,(function*(){const t=this.config.network.activeNetwork===_.g5.Mainnet?_.yp.Bitcoin:_.yp.BitcoinTestnet;try{const r=yield(0,x.I)(t,e);return P.Z.info("BTC",{hash:r}),r}catch(e){throw(0,S.t)("app:controller_errors.failed_to_broadcast_transaction",{error:e})}})))),Q(this,"getOrdinalBalance",(()=>ee(this,null,(function*(){var e,t,r,n;if(this.config.network.activeNetwork===_.g5.Testnet)return 0;const{wallets:s,activeWalletId:o}=Z.Z.getState().wallets,a=this.getId(),{address:i}=s[o].chainData[a],l=`${I.Z.get("NFT_API_HOST")}/v2.3/balance/nft?withoutMetaData=false&ethAddress=${i}&chains[]=${null==(e=this.getConfig().longName)?void 0:e.toLowerCase()}`,c=yield this.api.get(l,{headers:{"x-api-key":I.Z.get("NFT_API_KEY")}}),d=yield this.scanUTXOs(this.config.network.activeNetwork,i),u=null!=(n=null==(r=null==(t=c.data)?void 0:t.value)?void 0:r.bitcoin)?n:[];return d.reduce(((e,{hash:t,index:r,value:n})=>(u&&u.forEach((s=>{if(!s.nftData.location)return;const[o,a,i]=s.nftData.location.split(":");o===t&&r===Number(a)&&(e+=n)})),e)),0)})))),Q(this,"checkForOrdinals",((e,t,r,n)=>ee(this,null,(function*(){var s;if(this.config.network.activeNetwork===_.g5.Testnet)return{value:e,utxos:t};const o=`${I.Z.get("NFT_API_HOST")}/v2.3/balance/nft?withoutMetaData=false&ethAddress=${r}&chains[]=${null==(s=this.getType())?void 0:s.toLowerCase()}`,a=(yield this.api.get(o,{headers:{"x-api-key":I.Z.get("NFT_API_KEY")}})).data.value.bitcoin;if(n){const[r,s,o]=n.split(":"),i=t.findIndex((({hash:e,index:t})=>r===e&&t===Number(s)));if(i>-1){const r=t[i];return(t=t.filter((({hash:e,index:t})=>!a.find((r=>{if(!r.nftData.location)return!1;const[n,s,o]=r.nftData.location.split(":");return n===e&&t===Number(s)}))))).unshift(r),{value:e=r.value,utxos:t}}throw(0,S.t)("app:controller_errors.cant_send_ordinal_now")}return t=t.filter((({hash:e,index:t})=>!a.find((r=>{if(!r.nftData.location)return!1;const[n,s,o]=r.nftData.location.split(":");return n===e&&t===Number(s)})))),{value:e,utxos:t}})))),Q(this,"removeDetrimentalUXTOFromAmount",(e=>ee(this,null,(function*(){const{activeWalletId:t,wallets:r}=Z.Z.getState().wallets,n=r[t].chainData[this.getId()].address,s=yield this.scanUTXOs(this.config.network.activeNetwork,n),o=Number(e.toFixed(0));return(0,k.Fs)(s,o)})))),Q(this,"sendTx",((e,t,r)=>ee(this,null,(function*(){const{wallets:n}=Z.Z.getState().wallets,s=n[t];switch(s.walletInfo.type){case O.c.PkKeystore:{if(!r)throw(0,S.t)("app:controller_errors.no_credentionals_passed");const t=s.walletInfo.data,n=yield(0,E.Jy)(t.keystore,r.walletPassword),o=E.Si.fromString(n),a=yield this.buildTx({ordinalId:e.nftId,amount:(0,c.XZ)(B()(new p.BigNumber(e.amount).multipliedBy(1e8).toNumber())),sender:e.fromAddress,recipient:e.toAddress,memo:e.memo,feeRate:e.feeRate,network:(0,F.XL)(this.config.network.activeNetwork)}),i=se.getECPair().fromWIF(o.nspk.value.pk,te(this.config.network.activeNetwork));a.psbt.signAllInputs(i),a.psbt.finalizeAllInputs();const l=a.psbt.extractTransaction().toHex();return this.broadcastTx(l)}case O.c.Keystore:{if(!r)throw(0,S.t)("app:controller_errors.no_credentionals_passed");const t=s.walletInfo.data;return this.normalTx(e.fromAddress,e.toAddress,new p.BigNumber(e.amount).multipliedBy(1e8).toFixed().valueOf(),e.feeRate,t.keystore,r.walletPassword,t.walletIndex,e.nftId,e.memo)}case O.c.Ledger:case O.c.Trezor:{const t=s.walletInfo.data,r=yield this.buildTx({ordinalId:e.nftId,amount:(0,c.XZ)(new p.BigNumber(e.amount).multipliedBy(1e8).toFixed().valueOf()),sender:e.fromAddress,recipient:e.toAddress,memo:e.memo,feeRate:e.feeRate,network:(0,F.XL)(this.config.network.activeNetwork)}),n=yield(0,M.D)(s.walletInfo.type).signUTXOTransaction(this,t.derivationPath,t.walletIndex,r);return yield this.broadcastTx(n)}default:throw"SendTx not supported for bitcoin"}})))),Q(this,"signPsbt",((e,t,r)=>ee(this,null,(function*(){y.Wi(R);const{wallets:n}=Z.Z.getState().wallets,s=n[t];if(s.walletInfo.type===O.c.Keystore){if(!r)throw(0,S.t)("app:controller_errors.no_credentionals_passed");const t=s.walletInfo.data,n=yield(0,E.Jy)(t.keystore,r.walletPassword),o=se.getBtcKeys(n,t.walletIndex,(0,F.XL)(this.config.network.activeNetwork)),a=te(_.g5.Mainnet);let i=new y._B;if(e.psbtBase64)try{i=y._B.fromBase64(e.psbtBase64,{network:a})}catch(e){}if(e.psbtHex)try{i=y._B.fromHex(e.psbtHex,{network:a})}catch(e){}if(0===i.txInputs.length)throw(0,S.t)("app:controller_errors.please_add_inputs");const l=[],c=s.chainData[this.getId()].address;try{i.data.inputs.forEach(((e,t)=>{let r=new Buffer([]);if(e.witnessUtxo)r=e.witnessUtxo.script;else if(e.nonWitnessUtxo){r=y.YW.fromBuffer(e.nonWitnessUtxo).outs[i.txInputs[t].index].script}const n=e.finalScriptSig||e.finalScriptWitness;if(r&&!n){let n="";n=e.tapInternalKey&&(0,w.isTaprootInput)(i.data.inputs[t])?y.PP.p2tr({internalPubkey:e.tapInternalKey,network:a}).address||"":y.Lk.fromOutputScript(r),c===n&&l.push({index:t,sighashTypes:e.sighashType?[e.sighashType]:void 0})}}));const t=(e,t,r)=>se.getECPair().fromPublicKey(e).verify(t,r);if(0===l.length)throw(0,S.t)("app:controller_errors.no_relevant_input_to_sign");if(l.forEach((({sighashTypes:r,index:n})=>{i.signInput(n,o,r),i.validateSignaturesOfInput(n,t),e.finalise&&i.finalizeInput(n)})),e.psbtBase64)return i.toBase64();if(e.psbtHex)return i.toHex();throw"no psbt inputted"}catch(e){throw P.Z.info("ERROR in ",e),e}}throw"SignPSBT not supported for bitcoin"}))));const t=(0,h.setupCache)({maxAge:6e4});this.api=u().create({adapter:t.adapter})}getOwnedTokens(e){return Promise.resolve([])}getFees(){throw"Method not implemented."}getName(){return this.name}getSymbol(){return this.symbol}getImage(){var e;return null!=(e=this.image)?e:""}reloadJsonRpcProvidersUrls(){(0,K.noop)()}static getECPair(){return(0,T.eA)(R)}static getBip32(){return(0,f.GA)(R)}getAddress(e){if(!e.seed&&!e.pk||e.pk&&e.seed)throw"getAddress: Wrong arguments";if(e.pk){const t=se.getECPair().fromWIF(e.pk,this.getConfig().network.activeNetwork===_.g5.Mainnet?m().bitcoin.main.toBitcoinJS():m().bitcoin.test.toBitcoinJS()),{address:r}=y.PP.p2wpkh({pubkey:t.publicKey,network:this.getConfig().network.activeNetwork===_.g5.Mainnet?m().bitcoin.main.toBitcoinJS():m().bitcoin.test.toBitcoinJS()});if(!r)throw(0,S.t)("app:controller_errors.could_not_generate_address_from_pk");return{address:r}}if(e.seed){return{address:new a.KU({phrase:e.seed.seed.toString(),network:(0,F.XL)(this.config.network.activeNetwork)}).getAddress(e.seed.walletIndex)}}throw"getAddress: Wrong arguments"}getPrivateKey(e){if(!e.seed)throw"getPrivateKey: Wrong arguments";if(e.seed){return se.getBtcKeys(e.seed.toString(),e.walletIndex,(0,F.XL)(this.config.network.activeNetwork)).toWIF()}throw"getPrivateKey: wrong arguments"}getBalance(e){return ee(this,null,(function*(){const t=F.hv[this.config.network.chainId],r=C.u[t];return(yield(0,$.l)(r,e)).data[r].balances[0].amount.value}))}getChainBalanceStateUpdate(e){return new Promise(((t,r)=>{try{const{wallets:n}=Z.Z.getState().wallets,s=this.getId(),{address:a}=n[e].chainData[s];try{this.getBalance(a).then((n=>{if(this.config.network.activeNetwork!==_.g5.Mainnet)return t({walletId:e,chainId:s,chainBalance:n});this.getOrdinalBalance().then((r=>t({walletId:e,chainId:s,chainBalance:String(Number(n)-r)}))).catch(r)})).catch(r)}catch(e){P.Z.error(e),o.Tb(e),r(e)}}catch(e){P.Z.log(e),r(e)}}))}normalTx(e,t,r,n,s,o,i,d="",u){return ee(this,null,(function*(){const h=yield(0,l.decryptFromKeystore)(s,o),p=new a.KU({network:(0,F.XL)(this.config.network.activeNetwork),phrase:h.toString()}).getAddress(i);return p!==e?Promise.reject(`from address not matching wallet ${p} !=  + ${e}`):(P.Z.info("btcClient.transfer"),this.transfer({ordinalId:d,recipient:t,amount:(0,c.XZ)(r),feeRate:n,walletIndex:i,memo:u,phrase:h.toString(),sender:p}))}))}getFeeRates(){return ee(this,null,(function*(){var e;const{data:t}=yield(0,W.Z)(_.yp.Bitcoin,"network-only"),r=null==(e=null==t?void 0:t.bitcoin)?void 0:e.fee;return{[i.FeeOption.Fastest]:r.high/1e3,[i.FeeOption.Fast]:r.medium/1e3,[i.FeeOption.Average]:r.low/1e3}}))}static getFullDerivationPath(e,t){return re?`${re[t]}${e}`:""}static getBtcKeys(e,t=0,r){const n=(0,l.getSeed)(e),s=se.getBip32().fromSeed(n,te(r)).derivePath(se.getFullDerivationPath(t,r));if(!s.privateKey)throw(0,S.t)("app:controller_errors.couldnt_get_pk_from_phrase");return se.getECPair().fromPrivateKey(s.privateKey,{network:te(r)})}transfer(e){return ee(this,null,(function*(){const t=(null==e?void 0:e.walletIndex)||0,r=e.feeRate||(yield this.getFeeRates())[i.FeeOption.Fast],{psbt:n}=yield this.buildTx((s=((e,t)=>{for(var r in t||(t={}))V.call(t,r)&&G(e,r,t[r]);if(j)for(var r of j(t))Y.call(t,r)&&G(e,r,t[r]);return e})({},e),o={feeRate:r,sender:e.sender,network:(0,F.XL)(this.config.network.activeNetwork)},z(s,J(o))));var s,o;const a=se.getBtcKeys(e.phrase,t,(0,F.XL)(this.config.network.activeNetwork));n.signAllInputs(a),n.finalizeAllInputs();const l=n.extractTransaction().toHex();return this.broadcastTx(l)}))}buildTx(e){return ee(this,arguments,(function*({amount:e,recipient:t,memo:r,feeRate:n,sender:s,network:o,ordinalId:a}){if(r)if(r.startsWith("hex::")){if(r.length>165)throw"memo too long, must not be longer than 165 chars."}else if(r.length>80)throw(0,S.t)("app:controller_errors.memo_length_validation");const l=yield this.scanUTXOs(o===i.Network.Mainnet?_.g5.Mainnet:_.g5.Testnet,s),{utxos:c,value:d}=yield this.checkForOrdinals(e.amount().toNumber(),l,s,a);if(0===c.length)throw(0,S.t)("app:controller_errors.no_utxos_to_send");if(!se.validateAddress(t,this.config.network.activeNetwork))throw(0,S.t)("app:controller_errors.invalid_address");let u=n;if(!u){u=(yield this.getFeesWithRates(r)).rates.average}const h=Number(u.toFixed(0)),p=r?this.compileMemo(r):null,f=[];f.push({address:t,value:d}),p&&f.push({script:p,value:0});const{inputs:w,outputs:g}=ne(c,f,h,!!a);if(!w||!g)throw(0,S.t)("app:controller_errors.insufficient_balance");const m=new y._B({network:te(this.config.network.activeNetwork)});return m.setMaximumFeeRate(25e5),m.addInputs(w.map((e=>({hash:e.hash,index:e.index,witnessUtxo:e.witnessUtxo})))),g.forEach((e=>{e.address||(e.address=s),e.script?p&&m.addOutput({script:p,value:0}):m.addOutput(e)})),{psbt:m,utxos:c,inputs:w,outputs:g}}))}validateAddress(e){return se.validateAddress(e,this.config.network.activeNetwork)}static validateAddress(e,t){try{return y.Wi(R),y.Lk.toOutputScript(e,te(t)),!0}catch(e){return!1}}getTransactionFee(e){return ee(this,arguments,(function*({txData:e}){try{if(!e.fromAddress)throw(0,S.t)("app:controller_errors.empty_from_address");const t=e.feeRate,r=yield this.scanUTXOs(this.config.network.activeNetwork,e.fromAddress),{utxos:n,value:s}=yield this.checkForOrdinals(new p.BigNumber(e.amount).multipliedBy(1e8).toNumber(),r,e.fromAddress,e.nftId);if(0===n.length)throw P.Z.error("Error",n),(0,S.t)("app:controller_errors.no_utxos_to_send");const o=Number(t.toFixed(0)),a=e.memo?this.compileMemo(e.memo):null,i=[];i.push({address:e.toAddress,value:s}),a&&i.push({script:a,value:0});const{fee:l}=ne(n,i,o);return new p.BigNumber(l).dividedBy(1e8)}catch(e){throw P.Z.error("[BitcoinController] Failed to estimate transaction fee",e),e}}))}getFeesWithRates(e,t){return ee(this,null,(function*(){try{const r=t?yield this.scanUTXOs(this.config.network.activeNetwork,t):[],n=yield this.getFeeRates(),s=e?this.compileMemo(e):null;return{fees:{type:i.FeeType.PerByte,average:(0,c.XZ)((0,U.Gl)(r,n.average,s)),fast:(0,c.XZ)((0,U.Gl)(r,n.fast,s)),fastest:(0,c.XZ)((0,U.Gl)(r,n.fastest,s))},rates:n}}catch(e){return Promise.reject(e)}}))}approveDappTransaction(e,t,r,n){return ee(this,null,(function*(){var s,i;P.Z.info({msg:"BTC::approveDappTransaction",dappMessage:e,_overrides:n});const{wallets:c}=Z.Z.getState().wallets,d=c[t];if(this.getId()!==e.chainId)throw(0,S.t)("app:controller_errors.dapp_mesage_must_be_active_network");let u;try{u=e.raw}catch(e){throw P.Z.error(e),(0,o.Tb)(e),"XDEFI Malformed Bitcoin Payload"}switch(d.walletInfo.type){case O.c.PkKeystore:{if(!r)throw(0,S.t)("app:controller_errors.no_credentionals_passed");const t=d.walletInfo.data,s=yield(0,E.Jy)(t.keystore,r.walletPassword);let o;const a=L.j8.getFromAccountIMessage(e);if(!a)throw"From address i";if(u.method===_.tV.Transfer)try{o=u.params[0],n&&(o=Object.assign(o,n));const e=E.Si.fromString(s),t=(0,F.XL)(this.config.network.activeNetwork),r=yield this.buildTx({amount:(0,_.MS)(o.amount),sender:a,recipient:o.recipient,memo:o.memo,feeRate:o.feeRate,network:t}),i=se.getECPair().fromWIF(e.nspk.value.pk,te(this.config.network.activeNetwork));r.psbt.signAllInputs(i),r.psbt.finalizeAllInputs();const l=r.psbt.extractTransaction().toHex();return this.broadcastTx(l)}catch(e){throw e}throw`BitcoinController: Method ${u.method} not implemented`}case O.c.Keystore:if(!r)throw(0,S.t)("app:controller_errors.no_credentionals_passed");const t=d.walletInfo.data,c=yield(0,l.decryptFromKeystore)(t.keystore,r.walletPassword);let h,p;const f=L.j8.getFromAccountIMessage(e),y=new a.KU({network:(0,F.XL)(this.config.network.activeNetwork),phrase:c}).getAddress(t.walletIndex);if(y!==f)throw h=`from address not matching wallet ${y} !=  + ${f}`,h;switch(u.method){case _.tV.Transfer:let e;try{e=u.params[0]}catch(e){throw P.Z.error(e),(0,o.Tb)(e),"XDEFI Malformed Bitcoin Transfer Payload"}n&&(e=Object.assign(e,n));try{return p=yield this.transfer({recipient:(null==e?void 0:e.recipient)||"",amount:(0,_.MS)(null==e?void 0:e.amount),feeRate:Number((null==(s=null==e?void 0:e.feeRate)?void 0:s.toString())||"0"),walletIndex:t.walletIndex,memo:null==e?void 0:e.memo,phrase:c,sender:y}),p}catch(e){throw P.Z.error(e),(0,S.t)("app:controller_errors.transfer_failed_error",{error:e})}case _.VX.RequestAccounts:throw h="XDEFI Error: Request Accounts requests should not be in popup",h;default:throw"XDEFI Bitcoin Method not supported"}case O.c.Ledger:case O.c.Trezor:switch(u.method){case _.tV.Transfer:let e;try{e=u.params[0]}catch(e){throw P.Z.error(e),(0,o.Tb)(e),"XDEFI Malformed Bitcoin Transfer Payload"}n&&(e=Object.assign(e,n));try{const t=d.walletInfo.data,r=null==(i=null==e?void 0:e.feeRate)?void 0:i.toString(),n=yield this.buildTx({amount:(0,_.MS)(null==e?void 0:e.amount),sender:t.address,recipient:null==e?void 0:e.recipient,memo:null==e?void 0:e.memo,feeRate:Number(r),network:(0,F.XL)(this.config.network.activeNetwork)}),s=yield(0,M.D)(d.walletInfo.type).signUTXOTransaction(this,t.derivationPath,t.walletIndex,n);return yield this.broadcastTx(s)}catch(e){throw P.Z.error(e),(0,S.t)("app:controller_errors.transfer_failed_error",{error:e})}case _.VX.RequestAccounts:throw h="XDEFI Error: Request Accounts requests should not be in popup",h;default:throw"XDEFI Bitcoin Method not supported"}default:throw`approveDappTransaction not supported for walletType ${d.walletInfo.type}`}}))}validateTx(e){const t={};return""===e?t.toAddress="Address is required":this.validateAddress(e)||(t.toAddress="Address is not valid."),t}getTransactions(){return ee(this,null,(function*(){var e,t,r;const{activeWalletId:n,wallets:o}=Z.Z.getState().wallets,a=this.getId(),i=null==(r=null==(t=null==(e=null==o?void 0:o[n])?void 0:e.chainData)?void 0:t[a])?void 0:r.address;try{if(i){const e=this.config.network.activeNetwork===_.g5.Mainnet?_.yp.Bitcoin:_.yp.BitcoinTestnet,t=(yield(0,D.k)(e,i)).map((e=>{const t=Number((0,s.formatUnits)(e.balanceChange.value,8)),r=t<0;return{date:new Date(e.timestamp),from:i,to:i,action:r?"send":"receive",hash:e.hash,amount:Math.abs(t).toString(),status:"successful",symbol:this.getConfig().tokenSymbol,isSender:r,icon:this.getConfig().image,chainId:a}}));t.length&&(yield(0,A.h4)({walletId:n,chainId:a,transactions:t,blockNumber:0}))}}catch(e){P.Z.error(`bitcoin transaction error: ${e}`)}}))}compileMemo(e){if(e.startsWith("hex::")){e=e.split("hex::")[1];const t=Buffer.from(e,"hex");return y._v.compile([y.Jz.OP_RETURN,t])}const t=Buffer.from(e,"utf8");return y._v.compile([y.Jz.OP_RETURN,t])}isSignMessage(e){return e.raw.method===_.tV.SignPsbt}scanUTXOs(e,t){return ee(this,null,(function*(){const r=e===_.g5.Mainnet?_.yp.Bitcoin:_.yp.BitcoinTestnet;return(yield(0,X.d)(r,t)).map((e=>({witnessUtxo:y.YW.fromHex(e.oTxHex).outs[e.oIndex],hash:e.oTxHash,value:Number(e.value.value),index:e.oIndex,txHex:e.oTxHex})))}))}}const oe=se;n()}catch(e){n(e)}}))},882591:(e,t,r)=>{r.d(t,{u:()=>s});var n=r(831352);const s={[n.yp.Aurora]:"aurora",[n.yp.Avalanche]:"avalanche",[n.yp.Arbitrum]:"arbitrum",[n.yp.Fantom]:"fantom",[n.yp.BinanceSmartChain]:"binanceSmartChain",[n.yp.CronosEvm]:"cronosEVM",[n.yp.Ethereum]:"ethereum",[n.yp.Polygon]:"polygon",[n.yp.CantoEvm]:"cantoEVM",[n.yp.Optimism]:"optimism",[n.yp.Stargaze]:"stargaze",[n.yp.Bitcoin]:"bitcoin",[n.yp.Litecoin]:"litecoin",[n.yp.Dogecoin]:"dogecoin",[n.yp.BitcoinCash]:"bitcoincash",[n.yp.BitcoinTestnet]:"bitcoinTestnet",[n.yp.Solana]:"solana",[n.yp.Terra]:"terra",[n.yp.SeiTestnet]:"sei"}},661195:(e,t,r)=>{r.d(t,{Z:()=>i});var n=r(459457),s=r(357786),o=r(882591);const a=e=>s.Ps`
  query Fees {
    ${o.u[e]} {
      fee {
        high
        medium
        low
        __typename
      }
    }
  }
`,i=(e,t)=>n.Lp.query({query:a(e),fetchPolicy:t})},729357:(e,t,r)=>{r.d(t,{l:()=>o});var n=r(357786),s=r(459457);const o=(e,t,r)=>s.Lp.query({query:n.Ps`query getBalance($address: String!) {
      ${e} {
        balances(address: $address) {
          amount {
            scalingFactor
            value
          }
          asset {
            symbol
            name
            image
            id
            contract
          }
        }
      }
    }`,variables:{address:t},fetchPolicy:r})},712685:(e,t,r)=>{r.d(t,{I:()=>i});var n=r(357786),s=r(882591);const o=e=>{const t=s.u[e];if(!t)throw new Error(`No field for chainId ${e}`);return n.Ps`
    query broadcastUtxoTransaction($rawHex: String!) {
      ${t} {
        broadcastTransaction(rawHex: $rawHex)
      }
    }
  `};var a=r(459457);const i=(e,t)=>{return r=void 0,n=null,i=function*(){const r=s.u[e];if(!r)throw new Error(`No field for chainId ${e}`);return a.Lp.query({query:o(e),variables:{rawHex:t}}).then((e=>e.data[r].broadcastTransaction))},new Promise(((e,t)=>{var s=e=>{try{a(i.next(e))}catch(e){t(e)}},o=e=>{try{a(i.throw(e))}catch(e){t(e)}},a=t=>t.done?e(t.value):Promise.resolve(t.value).then(s,o);a((i=i.apply(r,n)).next())}));var r,n,i}},728147:(e,t,r)=>{r.d(t,{k:()=>i});var n=r(357786),s=r(882591);const o=e=>{const t=s.u[e];if(!t)throw new Error(`No field for chainId ${e}`);return n.Ps`
    query getTransactions($address: String!, $pageNumber: Int!, $pageSize: Int!) {
      ${t} {
        transactionsV2(
          address: $address
          pageNumber: $pageNumber
          pageSize: $pageSize
        ) {
          timestamp
          status
          hash
          blockNumber
          balanceChange {
            value
          }
        }
      }
    }
  `};var a=r(459457);const i=(e,t)=>{return r=void 0,n=null,i=function*(){const r=s.u[e];if(!r)throw new Error(`No field for chainId ${e}`);return a.Lp.query({query:o(e),fetchPolicy:"network-only",variables:{address:t,pageNumber:0,pageSize:25}}).then((e=>e.data[r].transactionsV2))},new Promise(((e,t)=>{var s=e=>{try{a(i.next(e))}catch(e){t(e)}},o=e=>{try{a(i.throw(e))}catch(e){t(e)}},a=t=>t.done?e(t.value):Promise.resolve(t.value).then(s,o);a((i=i.apply(r,n)).next())}));var r,n,i}},16547:(e,t,r)=>{r.d(t,{d:()=>i});var n=r(459457),s=r(357786),o=r(882591);const a=e=>{if(!o.u[e])throw new Error(`No field for chainId ${e}`);return s.Ps`
    query UnspentTxOutputs($address: String!, $page: Int!) {
      ${o.u[e]} {
        unspentTxOutputsV5(address: $address, page: $page) {
          address
          oIndex
          oTxHash
          oTxHex
          value {
            value
          }
        }
      }
    }
  `};const i=(e,t)=>{return r=void 0,s=null,i=function*(){const r=o.u[e];if(!r)throw new Error(`No field for chainId ${e}`);return n.Lp.query({query:a(e),fetchPolicy:"network-only",variables:{address:t,page:0}}).then((e=>e.data[r].unspentTxOutputsV5))},new Promise(((e,t)=>{var n=e=>{try{a(i.next(e))}catch(e){t(e)}},o=e=>{try{a(i.throw(e))}catch(e){t(e)}},a=t=>t.done?e(t.value):Promise.resolve(t.value).then(n,o);a((i=i.apply(r,s)).next())}));var r,s,i}}}]);
//# sourceMappingURL=9706.bundle.js.map